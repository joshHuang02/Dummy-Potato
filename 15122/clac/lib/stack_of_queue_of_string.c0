/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2020                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/


/*
 * Stacks of queues of strings
 *
 * 15-122 Principles of Imperative Computation */

#use <conio>
#use "queue_of_string.c0"
// The above line lets us use types from queue_of_string.c0 even if we
// don't include queue_of_string.c0 on the command line. It can
// sometimes cause problems with the autograder if you do this in your
// code, but it can also be a useful way of splitting your code into
// multiple files.


/*********** Implementation of stacks of queues of strings ***********/

/* Aux structure of linked lists of queues of strings */
typedef struct qlist_node qlist;
struct qlist_node {
  queue_t data;
  struct qlist_node* next;
};

/* is_segment_qlist(start, end) will diverge if list is circular! */
bool is_segment_qlist(qlist* start, qlist* end) {
  if (start == NULL) return false;
  if (start == end) return true;
  return start->data != NULL && is_segment_qlist(start->next, end);
}

/* Stacks of queues of strings */

typedef struct stack_of_queue_header qstack;
struct stack_of_queue_header {
  qlist* top;
  qlist* floor;
};

bool is_qstack(qstack* S) {
  return S != NULL
    && is_segment_qlist(S->top, S->floor);
}

bool qstack_empty(qstack* S)
//@requires is_qstack(S);
{
  return S->top == S->floor;
}

qstack* qstack_new()
//@ensures is_qstack(\result);
//@ensures qstack_empty(\result);
{
  qstack* S = alloc(qstack);
  qlist* l = alloc(qlist); /* does not need to be initialized! */
  S->top = l;
  S->floor = l;
  return S;
}

void qpush(qstack* S, queue_t x)
//@requires is_qstack(S);
//@ensures is_qstack(S);
//@requires x != NULL;
{
  qlist* l = alloc(qlist);
  l->data = x;
  l->next = S->top;
  S->top = l;
}

queue_t qpop(qstack* S)
//@requires is_qstack(S);
//@requires !qstack_empty(S);
//@ensures is_qstack(S);
//@ensures \result != NULL;
{
  queue_t x = S->top->data;
  S->top = S->top->next;
  return x;
}

void qstack_print(qstack* S)
//@requires is_qstack(S);
{
  print("TOP: ");
  for (qlist* l = S->top; l != S->floor; l = l->next) {
    if (l != S->top) print("     ");
    queue_print(l->data);
    if (l->next != S->floor) print("\n");
  }
}


// Client type
typedef qstack* qstack_t;


/*********** Interface to stacks of queues of strings ***********/

// typedef ______* qstack_t;

bool qstack_empty(qstack_t S)              /* O(1) */
/*@requires S != NULL;               @*/ ;

qstack_t qstack_new()                      /* O(1) */
/*@ensures \result != NULL;          @*/
/*@ensures qstack_empty(\result);    @*/ ;

void qpush(qstack_t S, queue_t x)          /* O(1) */
/*@requires S != NULL && x != NULL;  @*/
/*@ensures !qstack_empty(S);         @*/ ;

queue_t qpop(qstack_t S)                   /* O(1) */
/*@requires S != NULL;               @*/
/*@requires !qstack_empty(S);        @*/
/*@ensures \result != NULL;          @*/ ;

void qstack_print(qstack_t S)
/*@requires S != NULL;               @*/ ;
